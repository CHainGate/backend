/*
 * Public OpenAPI
 *
 * This is the public OpenAPI definition.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package publicService

import (
	"context"
	"errors"
	"github.com/google/uuid"
	"net/http"
	"strings"
	"time"

	"github.com/CHainGate/backend/ethClientApi"

	"github.com/CHainGate/backend/internal/repository/userRepository"

	"github.com/CHainGate/backend/internal/models"
	"github.com/CHainGate/backend/internal/utils"
	"github.com/CHainGate/backend/publicApi"
)

// PaymentApiService is a service that implements the logic for the PaymentApiServicer
// This service should implement the business logic for every endpoint for the PaymentApi API.
// Include any external packages or services that will be required by this service.
type PaymentApiService struct {
}

// NewPaymentApiService creates a default api service
func NewPaymentApiService() publicApi.PaymentApiServicer {
	return &PaymentApiService{}
}

// NewPayment - Create a new payment
func (s *PaymentApiService) NewPayment(_ context.Context, xAPIKEY string, paymentRequestDto publicApi.PaymentRequestDto) (publicApi.ImplResponse, error) {
	// only user data without preload, if needed add preload
	user, apiKey, err := verifyApiKeyAuthentication(xAPIKEY, userRepository.Repository)
	if err != nil {
		if err.Error() == "not authorized" {
			return publicApi.Response(http.StatusForbidden, nil), err
		}
		return publicApi.Response(http.StatusInternalServerError, nil), err
	}

	mode, ok := utils.ParseStringToModeEnum(apiKey.Mode)
	if !ok {
		return publicApi.Response(http.StatusInternalServerError, nil), err
	}

	resp, err := ethClientCall(paymentRequestDto.PriceCurrency, paymentRequestDto.PriceAmount, "wallet_add", mode)
	if err != nil {
		return publicApi.Response(http.StatusInternalServerError, nil), err
	}

	payment, err := handleEthClientCallResponse(resp, mode, paymentRequestDto.CallbackUrl, user)
	if err != nil {
		return publicApi.Response(http.StatusInternalServerError, nil), err
	}

	paymentResponseDto := publicApi.PaymentResponseDto{
		Id:            payment.Id.String(),
		PayAddress:    payment.PayAddress,
		PriceAmount:   payment.PriceAmount,
		PriceCurrency: payment.PriceCurrency,
		PayAmount:     payment.PaymentStatus[0].PayAmount,
		PayCurrency:   payment.PayCurrency,
		ActuallyPaid:  &payment.PaymentStatus[0].ActuallyPaid,
		CallbackUrl:   payment.CallbackUrl,
		PaymentStatus: payment.PaymentStatus[0].PaymentStatus,
		CreatedAt:     payment.CreatedAt,
		UpdatedAt:     payment.UpdatedAt,
	}
	return publicApi.Response(http.StatusCreated, paymentResponseDto), nil
}

func verifyApiKeyAuthentication(receivedApiKey string, repo userRepository.IUserRepository) (*models.User, *models.ApiKey, error) {
	decryptedApiKey, err := utils.Decrypt([]byte(utils.Opts.ApiKeySecret), receivedApiKey)
	if err != nil {
		return nil, nil, err
	}

	apiKeyDetails := strings.Split(decryptedApiKey, "_")
	apiKeyId := apiKeyDetails[0]
	apiKeySecret := apiKeyDetails[1]

	apiKey, err := repo.FindApiKeyById(apiKeyId)
	if err != nil {
		return nil, nil, err
	}

	apiKeyMode, ok := utils.ParseStringToApiKeyTypeEnum(apiKey.KeyType)
	if !ok {
		return nil, nil, errors.New("Wrong api key mode ")
	}

	if apiKeyMode == utils.Secret {
		encryptedKey, err := utils.ScryptPassword(apiKeySecret, apiKey.Salt)
		if err != nil {
			return nil, nil, err
		}

		if encryptedKey != apiKey.SecretKey {
			return nil, nil, errors.New("not authorized")
		}
	}

	if apiKeyMode == utils.Public {
		if apiKeySecret != apiKey.SecretKey {
			return nil, nil, errors.New("not authorized")
		}
	}

	user, err := repo.FindById(apiKey.UserId)
	if err != nil {
		return nil, nil, err
	}

	return user, apiKey, nil
}

func ethClientCall(priceCurrency string, priceAmount float64, wallet string, mode utils.Mode) (*ethClientApi.PaymentResponse, error) {
	paymentRequest := *ethClientApi.NewPaymentRequest(priceCurrency, priceAmount, wallet, mode.String())
	configuration := ethClientApi.NewConfiguration()
	apiClient := ethClientApi.NewAPIClient(configuration)
	resp, _, err := apiClient.PaymentApi.CreatePayment(context.Background()).PaymentRequest(paymentRequest).Execute()
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func handleEthClientCallResponse(resp *ethClientApi.PaymentResponse, mode utils.Mode, callbackUrl string, user *models.User) (*models.Payment, error) {
	blockChainPaymentId, err := uuid.Parse(resp.PaymentId)
	if err != nil {
		return nil, err
	}
	// TODO: get wallet from db
	/*	wallet := models.Wallet{
		Mode: mode.String(),
		Currency: "eth",
		Address: "asdwar88asd",
	}*/

	initialState := models.PaymentStatus{
		PaymentStatus: resp.PaymentStatus,
		PayAmount:     resp.PayAmount,
		ActuallyPaid:  0,
		CreatedAt:     time.Now(),
	}

	payment := models.Payment{
		Id:                  uuid.New(),
		Mode:                mode.String(),
		PriceAmount:         resp.PriceAmount,
		PriceCurrency:       resp.PriceCurrency,
		PayCurrency:         resp.PayCurrency,
		BlockchainPaymentId: blockChainPaymentId,
		PaymentStatus:       []models.PaymentStatus{initialState},
		CallbackUrl:         callbackUrl,
		CreatedAt:           time.Now(),
		UpdatedAt:           time.Now(),
		PayAddress:          resp.PayAddress, //TODO: currently not set from eth service
		Wallet:              user.Wallets[0],
	}

	user.Payments = append(user.Payments, payment)
	err = userRepository.Repository.UpdateUser(user)
	if err != nil {
		return nil, err
	}

	return &payment, nil
}
