/*
 * Config OpenAPI
 *
 * This is the config OpenAPI definition.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package configService

import (
	"context"
	"errors"
	"github.com/CHainGate/backend/configApi"
	"github.com/CHainGate/backend/internal/database"
	"github.com/CHainGate/backend/internal/models"
	"github.com/CHainGate/backend/internal/utils"
	"net/http"
	"time"

	"github.com/google/uuid"
)

// ApiKeyApiService is a service that implements the logic for the ApiKeyApiServicer
// This service should implement the business logic for every endpoint for the ApiKeyApi API.
// Include any external packages or services that will be required by this service.
type ApiKeyApiService struct {
}

// NewApiKeyApiService creates a default api service
func NewApiKeyApiService() configApi.ApiKeyApiServicer {
	return &ApiKeyApiService{}
}

// DeleteApiKey - delete api key
func (s *ApiKeyApiService) DeleteApiKey(_ context.Context, apiKeyId string, authorization string) (configApi.ImplResponse, error) {
	user, err := checkAuthorizationAndReturnUser(authorization)
	if err != nil {
		return configApi.Response(http.StatusForbidden, nil), errors.New("not authorized")
	}

	result := database.DB.Model(&models.ApiKey{}).Where("id = ? AND user_id = ?", apiKeyId, user.Id).Update("is_active", false)
	if result.Error != nil {
		return configApi.Response(http.StatusBadRequest, nil), errors.New("")
	}
	return configApi.Response(http.StatusNoContent, nil), nil
}

// GenerateApiKey - create new secret api key
func (s *ApiKeyApiService) GenerateApiKey(_ context.Context, authorization string, apiKeyRequestDto configApi.ApiKeyRequestDto) (configApi.ImplResponse, error) {
	user, err := checkAuthorizationAndReturnUser(authorization)
	if err != nil {
		return configApi.Response(http.StatusForbidden, nil), errors.New("not authorized")
	}

	mode, ok := utils.ParseStringToModeEnum(apiKeyRequestDto.Mode)
	if !ok {
		return configApi.Response(http.StatusBadRequest, nil), errors.New("mode does not exist")
	}

	apiKeyType, ok := utils.ParseStringToApiKeyTypeEnum(apiKeyRequestDto.KeyType)
	if !ok {
		return configApi.Response(http.StatusForbidden, nil), errors.New("api key type does not exist")
	}

	key := models.ApiKey{
		Id:        uuid.New(),
		Mode:      mode.String(),
		KeyType:   apiKeyType.String(),
		IsActive:  true,
		CreatedAt: time.Now(),
	}

	apiKeyDto := configApi.ApiKeyResponseDto{
		Id:        key.Id.String(),
		KeyType:   key.KeyType,
		CreatedAt: key.CreatedAt,
	}

	apiSecretKey, err := utils.GenerateApiKey()
	if err != nil {
		return configApi.Response(http.StatusInternalServerError, nil), err
	}

	if apiKeyType == utils.Secret {
		salt, err := utils.CreateSalt()
		if err != nil {
			return configApi.Response(http.StatusInternalServerError, nil), err
		}
		apiSecureKeyEncrypted, err := utils.ScryptApiKey(apiSecretKey, salt)
		if err != nil {
			return configApi.Response(http.StatusInternalServerError, nil), err
		}
		key.SecretKey = apiSecureKeyEncrypted
		key.Salt = salt

		combinedKey := key.Id.String() + "_" + apiSecretKey
		encryptAES, err := utils.Encrypt([]byte(utils.Opts.ApiKeySecret), combinedKey)
		if err != nil {
			return configApi.Response(http.StatusInternalServerError, nil), err
		}

		apiKeyBeginning := encryptAES[0:4]
		apiKeyEnding := encryptAES[len(encryptAES)-5:]
		key.ApiKey = apiKeyBeginning + "..." + apiKeyEnding // show the first and last 4 letters of the secret api key

		apiKeyDto.Key = encryptAES
	}

	if apiKeyType == utils.Public {
		combinedKey := key.Id.String() + "_" + apiSecretKey
		encryptAES, err := utils.Encrypt([]byte(utils.Opts.ApiKeySecret), combinedKey)
		if err != nil {
			return configApi.Response(http.StatusInternalServerError, nil), err
		}
		key.ApiKey = encryptAES
		key.SecretKey = apiSecretKey

		apiKeyDto.Key = encryptAES
	}

	user.ApiKeys = append(user.ApiKeys, key)
	result := database.DB.Save(&user)
	if result.Error != nil {
		return configApi.Response(http.StatusInternalServerError, nil), errors.New("User could not be updated ")
	}

	return configApi.Response(http.StatusCreated, apiKeyDto), nil
}

// GetApiKey - gets the api key
func (s *ApiKeyApiService) GetApiKey(_ context.Context, mode string, keyType string, authorization string) (configApi.ImplResponse, error) {
	user, err := checkAuthorizationAndReturnUser(authorization)
	if err != nil {
		return configApi.Response(http.StatusForbidden, nil), errors.New("not authorized")
	}

	enumMode, ok := utils.ParseStringToModeEnum(mode)
	if !ok {
		return configApi.Response(http.StatusBadRequest, nil), errors.New("mode does not exist")
	}

	enumApiKeyType, ok := utils.ParseStringToApiKeyTypeEnum(keyType)
	if !ok {
		return configApi.Response(http.StatusForbidden, nil), errors.New("api key type does not exist")
	}

	var keys []models.ApiKey
	result := database.DB.Where("user_id = ? and mode = ? and key_type = ?", user.Id, enumMode.String(), enumApiKeyType.String()).Find(&keys)
	if result.Error != nil {
		return configApi.Response(http.StatusInternalServerError, nil), errors.New("")
	}

	var resultList []configApi.ApiKeyResponseDto
	for _, item := range keys {
		resultList = append(resultList, configApi.ApiKeyResponseDto{
			Id:        item.Id.String(),
			Key:       item.ApiKey,
			KeyType:   item.KeyType,
			CreatedAt: item.CreatedAt,
		})
	}

	return configApi.Response(http.StatusOK, resultList), nil
}
