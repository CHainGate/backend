/*
 * Config OpenAPI
 *
 * This is the config OpenAPI definition.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package configService

import (
	"context"
	"errors"
	"net/http"

	"github.com/CHainGate/backend/internal/model"
	"github.com/CHainGate/backend/internal/repository"
	"github.com/CHainGate/backend/internal/service"
	"github.com/CHainGate/backend/pkg/enum"
	"github.com/google/uuid"

	"github.com/CHainGate/backend/configApi"
)

// WalletApiService is a service that implements the logic for the WalletApiServicer
// This service should implement the business logic for every endpoint for the WalletApi API.
// Include any external packages or services that will be required by this service.
type WalletApiService struct {
	authenticationService service.IAuthenticationService
	merchantRepository    repository.IMerchantRepository
}

// NewWalletApiService creates a default api service
func NewWalletApiService(
	authenticationService service.IAuthenticationService,
	merchantRepository repository.IMerchantRepository,
) configApi.WalletApiServicer {
	return &WalletApiService{authenticationService, merchantRepository}
}

// AddWallet - add new wallet address
func (s *WalletApiService) AddWallet(_ context.Context, authorization string, walletRequestDto configApi.WalletRequestDto) (configApi.ImplResponse, error) {
	merchant, err := s.authenticationService.HandleJwtAuthentication(authorization)
	if err != nil {
		return configApi.Response(http.StatusForbidden, nil), errors.New("not authorized")
	}

	mode, ok := enum.ParseStringToModeEnum(walletRequestDto.Mode)
	if !ok {

	}
	currency, ok := enum.ParseStringToCryptoCurrencyEnum(walletRequestDto.Currency)
	if !ok {

	}
	newWallet := model.Wallet{
		Base:     model.Base{ID: uuid.New()},
		Currency: currency,
		Address:  walletRequestDto.Address,
		Mode:     mode,
	}

	merchant.Wallets = append(merchant.Wallets, newWallet)
	err = s.merchantRepository.Update(merchant)
	if err != nil {
		return configApi.Response(http.StatusNotImplemented, nil), err
	}

	response := configApi.WalletResponseDto{
		Id:       newWallet.ID.String(),
		Address:  newWallet.Address,
		Mode:     newWallet.Mode.String(),
		Currency: newWallet.Currency.String(),
	}
	return configApi.Response(http.StatusCreated, response), nil
}

// DeleteWallet - delete wallet
func (s *WalletApiService) DeleteWallet(ctx context.Context, walletId string, authorization string) (configApi.ImplResponse, error) {
	_, err := s.authenticationService.HandleJwtAuthentication(authorization)
	if err != nil {
		return configApi.Response(http.StatusForbidden, nil), errors.New("not authorized")
	}

	err = s.merchantRepository.DeleteWalletById(walletId)
	if err != nil {
		return configApi.Response(http.StatusInternalServerError, nil), err
	}

	return configApi.Response(http.StatusOK, nil), nil
}

// GetWallets - get wallets
func (s *WalletApiService) GetWallets(ctx context.Context, mode string, authorization string) (configApi.ImplResponse, error) {
	merchant, err := s.authenticationService.HandleJwtAuthentication(authorization)
	if err != nil {
		return configApi.Response(http.StatusForbidden, nil), errors.New("not authorized")
	}

	result := make([]configApi.WalletResponseDto, 0)

	for _, wallet := range merchant.Wallets {
		result = append(result, configApi.WalletResponseDto{
			Id:       wallet.ID.String(),
			Mode:     wallet.Mode.String(),
			Currency: wallet.Currency.String(),
			Address:  wallet.Address,
		})
	}

	return configApi.Response(http.StatusOK, result), nil
}
